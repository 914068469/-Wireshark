#                                                       网络监听

监听软件：是一种监视网络状态，数据结构流程以及网络上信息传输的管理工具

原理：1.可以将网络接口设定成监听模式    2.可以截获网络上所传输的信息

防窃听方法：加密【如：将http变成https，或者先建立一个加密通道（如VPN）再进行连接】



| 过滤方法 | 用法                                                         |
| -------- | ------------------------------------------------------------ |
| 协议     | 如tcp ，只显示tcp                                            |
| IP地址   | ip.src ==源地址  ，ip.dst ==目标地址                         |
| 端口     | tcp.port ==80(只显示TCP端口为80)，tcp.srcport ==80(只显示TCP协议的源端口为80的) |
| http模式 | http.request.method =="GET",只显示TCP协议源端口为80          |
| 逻辑     | ip.scr ==192.168.1.1 or ip.scr ==192.168.1.1                 |



以太网包字段：1.目标地址  2.原地址  3.帧的类型

<h1>ARP协议（数据链接层）</h1>

1.ARP协议（地址解析协议）：通过解析网络层地址来找到数据链路层<br>                                                  网络传输协议，在IPv4中极其重要 。(物理地址=MAC地址）

2.ARP是通过IP地址解析来定位MAC地址。(物理地址=MAC地址）

3.arp缓存查看（如图所示）

![8](D:\IT教程\网络协议\导图\8.PNG)



4.Wireshark里的ARP请求与应答

|      Hardware type: Ethernet (1)  【1表示以太网】       |      硬件类型【链路层协议】      |
| :-----------------------------------------------------: | :------------------------------: |
|              Protocol type: IPv4 (0x0800)               |      协议类型【网络层协议】      |
|                    Hardware size: 6                     |           硬件地址长度           |
|                    Protocol size: 4                     |           协议地址长度           |
|                   Opcode: request (1)                   | 操作字段【1表示请求，2表示响应】 |
| Sender MAC address: Vmware_c0:00:08 (00:50:56:c0:00:08) |         发送端的硬件地址         |
|             Sender IP address: 192.168.10.1             |          发送端的IP地址          |
| Target MAC address: Vmware_d6:ac:96 (00:0c:29:d6:ac:96) |         目标端的硬件地址         |
|            Target IP address: 192.168.10.128            |          目标端的IP地址          |

<h1>ICMP协议（网络层）</h1>

ICMP：是IP的子协议，负责传递错误消息的报文和其他需要注意的地方，与包状态的协议。

ICMP功能

![Type（类型）,Code（报文）报文类型](D:\IT教程\网络协议\导图\Type（类型）,Code（报文）报文类型.png)





ICMP工作原理：客户端向服务器发送Echo Requeest ,服务器发送Echo Reply返回到客户端，通过Echo     Reply来确定连接质量。

ping是调用了ICMP的Echo的请求与响应的概念

<img src="D:\IT教程\网络协议\导图\报文类型.jpg">

<h1>DNS协议（应用层）</h1>

1.DNS=域名解析系统

2.DNS用的最多的是UDP53，有时候也会用到TCP53。（UDP与TCP是传输层的协议）

3.UDP包承载的最大报文是512个字节

4.DNS使用TCP53的情况：1.查询或反馈的内容过长   2.在多个DNS服务器传递的过程

5.DNS查询：1.正向查询（域名查IP）     2.反向查询(IP查域名)

6.DNS使用的端口是53

7.域名解析记录类型：1.A      2.Cname    3.NS   4.MX    5.PTR

|   A   |  正向解析（将域名与IP关联起来，是大多数客户端默认查询类型）  |
| :---: | :----------------------------------------------------------: |
|  PTR  |    反向解析（将IP地址对应到域名，记录保存在in-addr.arpa）    |
| Cname |        别名记录（记录允许你将多个域名映对应到同一IP）        |
|  MX   |                  邮件记录（指向邮件服务器）                  |
|  NS   | 名称服务器（记录是域名服务器记录，也称授权服务器，用来指定哪个DNS服务器来解析域名） |

8.DNS缓存服务器：该服务器不解析域名，只是缓存域名解析结果。

9.DNS查询方式：1.递归查询       2.迭代查询

10.DNS查询过程（如下表格所示）

| 1.浏览器缓存                             |
| ---------------------------------------- |
| 2.系统缓存 （查hosts文件）               |
| 3.路由器缓存                             |
| 4.供应商的DNS缓存（一般是本地DNS服务器） |
| 5.根域服务器                             |
| 6.顶级域名服务器                         |
| 7.主域名服务器                           |
| 8.保存结果至缓存                         |







<h2>Flags: 0x0100 Standard query的内容</h2>

|                       Answer RRs: 0                       |                        资源记录                         |
| :-------------------------------------------------------: | :-----------------------------------------------------: |
|                     Authority RRs: 0                      |                        授权记录                         |
|    0... .... .... .... = Response: Message is a query     |              查询字段（0是查询，1是响应）               |
|     .000 0... .... .... = Opcode: Standard query (0)      | 操作字段（0是标准查询，1是反向查询，2是服务器状态查询） |
| .... ..0. .... .... = Truncated: Message is not truncated |          是否被截断（截断例子：www.baidu.com）          |

<img src="导图\捕获.PNG">

<h2>Queries的内容</h2>

| Type: A (Host Address) (1) |    查询类型（A是主机记录）     |
| :------------------------: | :----------------------------: |
|     Class: IN (0x0001)     | 查询类字段（IN表示互联网地址） |

<img src="导图\1.PNG">

注：DNS本身是不加密的！！！



<h1>TCP（传输层）的三层握手与四次挥手</h1>

1.TCP是一个面向可靠的，连接的，基于IP的传输层协议，可处理数据传输错误

2.所有TCP通信都会使用源端口和目的端口，可以在头部找到（连接远程服务器，TCP要知道该服务器监听的端口。）可使用端口为65535个。

3.每次握手时，会发送的数据为TCP报文

3.TCP报文：有源目的地址，端口号，初始序列号等。

4.三次握手：[1]第一次握手【由客户机向服务器发送请求包（SYN=1，客户机的序列号）】

​                       [2]第二次握手【由服务器向客户机发送响应包（ACK=SYN+1）与确认包(SYN=3，服务  器的序列号)】

​                       [3]第三次握手【服务器向客户机法送响应包（ACK=SYN+1）】

​                       [4]开始标准数据传输

<img src="导图\2.png">

5.四次挥手：[1]客户端向服务器发送FIN包，客户端进入wait1状态

​                       [2]服务器收到报文后，向客户端发送ACK报文，服务端进入closed_wait（关闭等待状 态）,客户端进入wait2状态<br>                           ( 客户端已经收到ACK报文）

​                       [3]服务端向客户端发送FIN报文（确认状态），

​                       [4]客户端向服务端发送ACK包（进入超时等待状态，保证对方已收到ACK包）

 6.TCP是在不可靠的网络链路中建立可靠的连接

<h2>标志位</h2>



| SYN  |            同步序号            |
| :--: | :----------------------------: |
| ACK  |     答应回复（同步序号+1）     |
| RST  | 复位连接，消除旧有的同步序列号 |
| PSH  |   尽可能的将数据送往接收进程   |
| FIN  |       发送方完成数据发送       |



<h2>Transmission Control Protocol的内容</h2>

|                Source Port: 53103                | 源的端口（本地端口） |
| :----------------------------------------------: | :------------------: |
|               Destination Port: 80               |       目标端口       |
| Sequence number: 0    (relative sequence number) |        序列号        |












<h1>IP协议（网络层）</h2>

1.IP协议是在OSI中的网络层

2.主要的目的是网络之间能互相通信

|   MAC地址    |   IP地址   |
| :----------: | :--------: |
|  数据链路层  |   网络层   |
| 单一网络通信 | 跨网络通信 |

3.常用的IP协议有:IPV4（使用32位地址）和IPV6（使用128位地址）

4.IP的重要概念：【1】存活时间（TTL,）—— 该数据包在丢弃之前经历的之间，<br>                                        此值是在数据包创建时设置的。当TTL变成0是，代表这<br>                                        个数据包被丢弃。（与路由器有关）

​                              【2】分片——将一个数据流分为小的片段，是IP用于解决跨越<br>

​                                          不同类型网络可靠传输的特性。

5. 分片原因：当数据包大于网络接口的MTU（MTU是指最大传输数据）

6. 分片的步骤（如表格所示）

   |           第一步：设备将数据分成可以传输的数据包           |
   | :--------------------------------------------------------: |
   |    第二步：IP头的域会被分为片段长度  (如10.11.125.250)     |
   | 第三步：更多分片数据包会被设置为1，最后一个数据包会设置为0 |
   |             第四步：IP投入部分数据包将会被设置             |
   |                  第五步：数据包被发送数去                  |

7.IP数据包的捕获：使用ping命令捕获ICMP数据包

8.Wireshark捕获IPV4数据包实验步骤：

  【1】打开Wireshark，在菜单栏里点击捕获![3](D:\IT教程\网络协议\导图\3.PNG)

   【2】点击选项，选择好接口，在“接口的捕获过滤器”里输入ip   

​           ![4](D:\IT教程\网络协议\导图\4.PNG)             

   【3】打开命令行（Windows的是CMD，linux的是Termux）,通过ping目标主机的IP地   址，就可以捕获到与IP有关的数据包。

<img src="D:\IT教程\网络协议\导图\5.png">

<img src="D:\IT教程\网络协议\导图\6.png">

<font color="red">注：两台主机之间没有路由器，因此TTL值没有产生变化</font>

但可以捕获IP分片包

9.捕获IP分片包实验步骤：

​          【1】在ping命令加个-i {如：ping 192.168.10.133 -i 3000（-i 3000 的作用是设置捕获数据包的大小为3000.）}![7](D:\IT教程\网络协议\导图\7.PNG)

10.<font color="red">注：在同一个网络中，IP地址具有唯一性</font>

11.如何获得IP：1.静态IP        2.动态IP DHCP



<h2>HTTP协议（应用层）</h2>
1.WEB系统最核心的内容，是WEB服务器与客户端 进行数据传输的规则

2.HTTP是无状态协议（这里的无状态指的是服务器与客户端不需要建立持久的连接）

3.HTTP遵循的是请求与应答的模型

4.HTTP连接的4个阶段(表格如下)

|    1.建立连接（TCP三次握手，与服务器建立连接）     |
| :------------------------------------------------: |
|    2.发送请求信息（客户端向服务器发送HTTP请求）    |
| 3.发送响应信息（服务器回复响应，向客户端回复数据） |
|    4.关闭连接（TCP四次挥手，与服务器断开连接）     |

5.端口号：80 （但有时候也会8080端口）

6.通过Wireshark捕获HTTP数据包实验步骤：

【1】打开Wireshark，对网页进行抓包并过滤

![10](D:\IT教程\网络协议\导图\10.PNG)

<font color="red">注：这里是筛选出HTTP的GET</font>

【2】查看请求方法,（GET）![11](D:\IT教程\网络协议\导图\11.PNG)

【3】查看请求版本![12](D:\IT教程\网络协议\导图\12.PNG)

【4】查看WEB服务器的目录（这里的”/“表示根目录）

![13](D:\IT教程\网络协议\导图\13.PNG)

【5】查看浏览器支持语言

![14](D:\IT教程\网络协议\导图\14.PNG)

【7】GET的其他内容（如下表格所示）

| User-Agent |       使用的用户代理       |
| :--------: | :------------------------: |
|   Cookie   | 存储在浏览器目录的文本文件 |
| Staus Code |           响应码           |

【8】POST的内容（如下表格所示）

| Request Method  |                       使用方法                       |
| :-------------: | :--------------------------------------------------: |
| Request Version |                       请求版本                       |
| Staus Code：302 |        响应码（302是HTTP常用的重定向的手段）         |
|    Location     | 客户端被重定向的位置（也是数据发表的原先的网页位置） |





<h2>HTTPS(应用层，HTTP的安全版)</h2>

1.基于SSL的安全超文本传输协议

2.使用安全的套接字层进行信息交换

3.HTTPS应用了SSL来作为应用层的子层

4.端口号：443

5.SSL使用40位关键字作为RC4加密

6.TLS（安全传输层协议）  SSL（安全套接层协议）

7.HTTPS的工作流程（如下表格所示）

| 1.客户端使用URL访问WEB服务器（要与WEB服务器建立SSL连接）     |
| ------------------------------------------------------------ |
| 2.WEB服务器收到客户端请求后，会把证书信息传输给客户端        |
| 3.客户端与服务器开始评估SSL连接的安全等级（信息安全加密的等级） |
| 4.同意后，双方建立会话密钥                                   |
| 5.利用网站加密会话密钥，并传送结网站                         |
| 6.服务器利用自己的私钥解开密钥                               |
| 7.服务器利用互换密钥加密与客户端之间的通信                   |

8.TLS包里的SSL内容（表感如下）

|                       version: TLS1.2                        |                     客户端支持的TLS版本                      |
| :----------------------------------------------------------: | :----------------------------------------------------------: |
|                            Random                            |                         生成对话密钥                         |
|                        Cipher suites                         |                       支持几种加密算法                       |
|                     Compression Methods                      |                        支持的压缩方式                        |
| Cipher Suite: TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA(服务器里的SSL) | 加密套件（在这里的意思是使用AES加密，用SHA进行解密，使用SRA来验证证书） |
|                  Cerificate (服务端里的SSL)                  |                          证书的信息                          |

<font color="red">注：如果SSL证书过期会显示警告问客户端是否继续访问(如图所示)</font>

![15](D:\IT教程\网络协议\导图\15.png)

9.HTTPS解密











<h2>FTP协议（应用层）</h2>

1.是文件传输协议，此协议分为两个部分（1.FTP服务器    2.FTP客户端）

2.FTP服务器用于文件存储，用户可以通过FTP协议来访问位于FTP服务器上的资源

3.FTP传输效率高，在网络上传输较大的文件时都会用的FTP协议

4.端口号：20和21

| 端口号 |                作用                |
| :----: | :--------------------------------: |
|   20   | 用于在客户端和服务器之间传输数据流 |
|   21   | 用于传输控制流，是通向服务器的入口 |

5.控制连接与数据连接都是TCP连接，（具体内容如表格所示）

| 控制连接 | 传送用户名与密码，及设置与传输方式 |
| :------: | :--------------------------------: |
| 数据连接 |            传输文件数据            |

<p align="center"><font color="red">注：客户端运行着控制进程，服务器运行运行着数据进程</font>

6.工作模式与其他网络协议有区别，使用HTTP协议时，通信双方只用1个端口，而FTP是使用两个独立的端口

7.优点与缺点（如表格所示）

|                    优点                     |                             缺点                             |
| :-----------------------------------------: | :----------------------------------------------------------: |
|           使网络数据传输分工明确            |                      数据传输模式不合理                      |
| 在文件传输时，可以用控制连接来传送控制消息  |                      工作方式设计不合理                      |
|                 传输速度快                  | 与防火墙不协调【在搭建ftp服务器是（不管是Windows sever还是Linux），要把防火墙关闭，才能传输文件】 |
| 通过SSL，SSH2进行安全加密，保证数据不被截取 |                        密码安全不完善                        |
|                完全基于网络                 |                 效率低下（交换握手步骤繁复）                 |

8.FTP是使用明文进行传输，用户名与密码可以在Wireshark里进行查看

9.FTP分为主动模式（由服务器主动发起）与被动模式

10.Windows自带的FTP只支持主动模式

11.在Wireshark里的FTP数据包（登路过程）

|                 数据包                  |             数据包里的内容             |
| :-------------------------------------: | :------------------------------------: |
|            Request: USER XXX            | 输入用户名XXX,请求命令为USER,参数为XXX |
| Response: 331 password required for XXX |            要XXX用户的密码             |
|          Request: PASS 123456           |    输入密码123456，请求的命令为PASS    |
|         Response：230 login OK          |    密码正确，状态码230表示登路成功     |

12.FTP响应码

| 响应码 |              作用              |
| :----: | :----------------------------: |
|  211   |            退出网络            |
|  150   |            打开连接            |
|  125   |     打开数据连接，开始传输     |
|  200   |              成功              |
|  277   | 进入被动模式（IP地址，ID端口） |
|  331   |            要求密码            |
|  332   |            要求账户            |
|  421   |            服务关闭            |
|  426   |            结束连接            |
|  250   |            文件路径            |
|  230   |           登路因特网           |
|  215   |          系统类型回复          |
|  211   |            系统状态            |







<h2>Kerberos（应用层）</h2>

1.Kerberos是计算机网络认证协议

2.允许一个实体在非安全的网络环境通信 ，可以向另外一个实体以一种安全的方式来证明自己的身份

3.主要针对客户与服务器模型的交互认证

4.保护网络实体免受窃听和重放攻击 

5.基于对称密码学，要值得信赖的第三方作为中介

6.Kerberos在实际的网络认证结果是双向的

7.双向认证方式: 互报接头暗号 (最简单的方式)

8.双向认证缺点：管理不便

9.KDC是Kerberos的第三方认证方式

10.时间戳是使用[数字签名](https://baike.baidu.com/item/数字签名/212550)技术产生的数据，对象包括了原始文件信息、签名参数、签名时间等信息

11.重放攻击：黑客在网络截获到时间戳，伪装成客户端账号，来欺骗服务器

12.工作流程（如表格所示）

| 1.客户端账号与KDC认证（用哈希函数将密码转换成密钥，Key-Client表示时间戳） |
| :----------------------------------------------------------: |
|   2.用Key-Client把当前的时间戳加密，生成一个字符串发给KDC    |
| 3.将客户端账号生成的信息发给KDC（Kerberos身份认证请求，AS-REQ=Key-Client） |
| 4.当KDS收到客户端账号信息，调出A的密码，使用 哈希函数转化成Key-Client |
|    5.KDC要想客户端账号证明身份（假的KDC是没有Key-Client）    |

13.用Wireshark对Kerberos协议数据包1进行分析（实验步骤如下）

![23](D:\IT教程\网络协议\导图\23.PNG)

【1】在这里我们可以在Wireshark官网提供的文件中下载

​           （链接：https://wiki.wireshark.org/SampleCaptures#Kerberos_and_keytab_file_for_decryption）

![16](D:\IT教程\网络协议\导图\16.PNG)

【2】打开Wireshark，打开文件krb-816（未被解密的文件）

![17](D:\IT教程\网络协议\导图\17.PNG)

【3】打开编辑，选首先项，选择Protocols，在Protocols里选择KBS5，在KBS5里面选中816.keytab

​        （这一步是导入密钥文件，进行解密）<font color=red>     注：此功能只能32位的Wireshark</font>

![19](D:\IT教程\网络协议\导图\19.PNG)

![20](D:\IT教程\网络协议\导图\20.PNG)

【4】打开cname，在name-string里面kerberosString显示的内容是客户端账号的信息

![21](D:\IT教程\网络协议\导图\21.PNG)

【5】打开sname,里面的nonce显示内容是是随机的字符串

![21](D:\IT教程\网络协议\导图\21.PNG)



14.用Wireshark对Kerberos协议数据包4进行分析（实验步骤如下）

![24](D:\IT教程\网络协议\导图\24.PNG)

【1】打开ticket,里面的key表示的是Key-Client的KDC

![25](D:\IT教程\网络协议\导图\25.PNG)

【2】ticket里面的lr-value表示的是时间戳

![25](D:\IT教程\网络协议\导图\25.PNG)

【3】ticket里面的nonce表示随机字符串

![25](D:\IT教程\网络协议\导图\25.PNG)









<h2>Linux中的NFS协议（应用层）</h2>

1.NFS是指网络文件系统，允许计算机网络之间通过TCP/IP网络共享资源

2.在NFS的应用中，本地的NSF客户端应用可以透明的读取远端服务器的文件

3.利用Wireshark来分析NFS数据包（实验步骤如图所示）

​    【1】在这里我们可以在Wireshark官网提供的文件中下载捕获过的文件

​            （链接：https://wiki.wireshark.org/SampleCaptures#NFS_Protocol_Family）

![26](D:\IT教程\网络协议\导图\26.PNG)

​       【2】用Wireshark打开文件nfsv2

![27](D:\IT教程\网络协议\导图\27.PNG)

  

 4.NFS数据包分析（挂载过程表格如下）

|  数据包   |                      信息                       |                           表达含义                           |
| :-------: | :---------------------------------------------: | :----------------------------------------------------------: |
| 1.portmap |  GETPORT CALL (Reply In 2) NSF(100003) V:3 TCP  | 客户端链接服务器的NFS进程 ，询问端口,这里的Reply In 2是指2号数据包就是对于1号数据包的回应 |
| 2.portmap |      GETPORT Reply (Call In 1)  port:2049       | 服务器回应客户端并告诉客户端连接端口为2049（回应1号数据包）  |
|   3.NFS   |    NULL Call（Reply in 4)[Malformed packet]     | 客户端尝试连接服务器的NFS进程，并且可以判断2049号端口是否被防火墙拦截，判断NFS是否已经启动 |
|   4.NFS   |    NULL Reply（call in 3)[Malformed packet]     |                      收到请求，可以连接                      |
| 5.portmap | GETPORT CALL(Reply In 6)  MOUNT(100005) V:3 UDP | 客户端连接服务器的挂载服务(MOUNT服务，由于MOUNT服务端口号是随机的，) |
| 6.portmap |      GETPORT Reply (Call In 5)  port:1234       |           服务器回应MOUNT端口号，MOUNT端口号为1234           |
|  7.MOUNT  |    NULL Call （REPLY In 8)[Malformed packet]    | 客户端连接MOUNT进程，判断1234端口是否被防火墙拦截，判断MOUNT是否已经启动 |
|  8.MOUNT  |         NULL Call （REPLY In 10)  /code         |      请求挂载的/code共享目录（NSF提供了code与dockkill）      |
|  9.MOUNT  |              MNT Reply (Call In 9)              | 服务器同意客户端的请求（通过查看 MOUNT Service 里的fhandle可以看到目录访问，如图所示） |

![28](D:\IT教程\网络协议\导图\28.PNG)



5.NFS的安全机制主要包括（1.客户端的访问控制  2.用户的权限控制）

| 客户端的访问控制 |     通过IP实现      |
| :--------------: | :-----------------: |
|  用户的权限控制  | 通过UID映射来实现的 |



6.NFS写入方式：1.异步（默认）       2.同步

7.请求与回应是同步出现

8.NFS的读写性能有问题，可以用Wireshark来查看是否打开了同步







<h2>Windows中CIFS(应用层)</h2>

1.CIFS是Windows里的文件共享的网络协议

2.基于TCP的，由TCP三次握手来开始

3.CIFS端口号是445

4.CIFS协议有三个版本：【1】SMB   【2】SMB2   【3】SMB3

5.目前SMB2和SMB比较常用

6.通过Wireshark来分析SMB协议  (分析4号数据包)

​      【1】在这里我们可以在Wireshark官网提供的文件中下载捕获过的文件

​               （链接：https://wiki.wireshark.org/SampleCaptures#SMB-Locking）

  ![29](D:\IT教程\网络协议\导图\29.PNG)

​     【2】用Wireshark打开文件SMB-locking

​         <font color="red">（ 注：4号数据包是协商数据包）</font>.![30](D:\IT教程\网络协议\导图\30.PNG)

   【3】4号数据包内容分析 (SMB Header的内容)

| Dialect:SMB 2.002 | 协议版本号 |
| :---------------: | :--------: |

   【4】5号数据包——Negotiate Protocol的内容分析  <font color="red">(5号数据包是回应4号数据号的)</font>

| Selected Index: 5: NT LM 0.12 | 服务器版本 |
| :---------------------------: | :--------: |



7.当服务器与客户端协商好之后，就可以建立Session Setup。

8.Session Setup作用进行身份的验证，验证方法如下

| 验证方法 |
| :------: |
|   NTLM   |
|    LM    |

9.如果访问不了CIFS服务器的情况，问题很有可能是在Session Setup。

10.Session Setup完成时，意味着打开了服务器,接下来要打开DEST的共享（第15号数据包）

11.Tree Connect 不会检查权限，即使无权也可以得到Tree ID

12.Create是CIFS中的一个重要操作，文件新建和文件打开等都要用到Create

13.CIFS缓存数据移植的方法：客户端可以把文件缓存在本地，等用完该文完后

​                                                      ，在同步回到服务器端。当只有1个 客户端是                  

​                                                      会比较安全。

14.如果有多个客户端访问同一个文件，CIFS会采用oplock机会锁来保证安全性

15.Oplock形式：【1】允许读写内存      【2】允许缓存的所以操作    【3】只允许读缓存

16.Oplock是在Create里实现的（数据包内容如下表格）

| Oplock level:Batch Oplock granted (2) | 表示客户端受于Batch机会锁，表示客户端可以缓存所以操作 |
| :-----------------------------------: | :---------------------------------------------------: |

17.在"Read AndX Response, FID: 0x8007, 85 bytes“里的File Data里面可以看到文件的内容

 





<h2>电子邮件服务协议【SMTP,POP和IMAP(应用层)】</h2>

1.电子邮件支持图片，文字和声音等多种形式

2.可以使用电子邮件客户端来使用电子邮件的服务

3.电子邮件是基于客户端服务器模式（CS模式）

4.电子邮件的传输过程是由多个软件程序组成【组成部分如表格所示】

|                           组成部分                           |
| :----------------------------------------------------------: |
|    MUA--用户代理（作用：为用户提供发送，接收和管理界面）     |
| MTA--传输代理（作用：接收客户端软件发送的邮件，并将邮件传输到其他MTA程序）<font color="red">核心部分</font> |
| MDA--分发代理（作用：负责在服务器中将邮件分发到用户邮箱目录。）注：MDA不直接面向邮箱目录的，一般在后台工作 |

5.电子邮件传输过程（如下表格所示）    

|                 1.MUA是使用SMTP协议发送给MTA                 |
| :----------------------------------------------------------: |
| 2.MTA收到信息，会根据收件人的信息来决定下一步（如果收件人是本系统用户就直接投递，反则把邮件传递到对方网络系统的MTA）注：任何MTA都可以承担收发的功能 |
| 3.MDA再把邮件投递到收件人信箱里（形式：普通目录或专用的数据库） |
|     4.收件人通过MUA来读取文件（读取邮件协议：POP和IMAP）     |

```
                      SMTP协议

6.SMTP是一种用于原地址到目的地址传送邮件的规则，控制信件的中转方式

7.SMTP属于TCP/IP协议族，端口号为25，使用TCP可靠的传输服务器

8.SMTP帮助计算机在发送或中转信件的时候找到目的地

9.通过SMTP所指定的服务器就可以吧E-mail寄到收信人的服务器上

10.SMTP的客户端与服务端同时运行在每个邮件服务器上
```



```
                      POP协议

11.POP用于在邮件服务器中收取邮件 （最新版本为POP3）

12.大多数MUA软件都支持使用POP协议

13.POP使用端口为110，工作模型与SMTP类似

14.POP工作三大步骤（表格如下）

|          1.客户端向POP服务器的110号端口发送连接请求          |
| :----------------------------------------------------------: |
|        2.建立连接之后，客户端可以向服务器发送POP命令         |
| 3.服务器收到命令后，根据情况决定是否执行该命令，给客户端回复相应的问答                      
```

​    

```
                       IMAP协议

15.IMAP用于邮件客户端可以通过此协议从邮件服务器上获取或下载邮件的信息

16.IMAP协议运行在TCP/IP协议之上，端口号为143

17.与POP的区别是用户可以不用把使用的邮件全部下载，可通过客户端直接对服务器上的邮件进行操作
```

19.用Wireshark来分析邮件协议（如下所示）

​     【1】在这里我们可以在Wireshark官网提供的文件中下载捕获过的文件 (连接：https://wiki.wireshark.org/SampleCaptures#Sample_Captures)  ![31](D:\IT教程\网络协议\导图\31.PNG)



 【2】用Wireshark打开文件smtp文件

​    ![32](D:\IT教程\网络协议\导图\32.PNG)



  【3】使用筛选器来筛选出SMTP协议

​       ![32](D:\IT教程\网络协议\导图\33.PNG)



 【4】在这里我们先看5号数据包，5号数据包用于向服务器表明身份，EHLO后面是客户机的名称

​     ![34](D:\IT教程\网络协议\导图\34.PNG)

 

 【5】在这里我们看10号数据包，10号数据包表示请求登路验证，AUTH LOGIN表示登路验证

![35](D:\IT教程\网络协议\导图\35.PNG)



 【6】第12号数据包里的User指令表示用户登路名称，用户登路名称经过加密，在这里可以说明SMTP不接受明文的，（如果在登路名称的最后用"=="则该名称采用Bass64加密）

![36](D:\IT教程\网络协议\导图\36.PNG)

​     

​     【7】第14号数据包里的Pass表示登录密码，这里采用了Bass64编码对密码进行了加密

![37](D:\IT教程\网络协议\导图\37.PNG)

​     

​    【8】第17号数据包表示登路成功

![38](D:\IT教程\网络协议\导图\38.PNG)

​    

   【9】第23号数据包里的DATE表示客户端发的内容  ![39](D:\IT教程\网络协议\导图\39.PNG)

  

   【10】第21号数据包表示服务器端使用了“.”作为结束符

![40](D:\IT教程\网络协议\导图\40.PNG)



​     【11】第41号数据包表示断开连接

![41](D:\IT教程\网络协议\导图\41.PNG)

​       

​     【12】如果想要查看发送邮件的详细信息，可以在内容为DATE fragment的数据包单击鼠标右键，选择则跟踪流，选TCP流，就可以查看邮件里面的内容（注：红色的部分是客户的发送的信息，而蓝色的是服务器响应信息）

![42](D:\IT教程\网络协议\导图\42.PNG)

​    



20.POP支持明文传输(包括用户名密码)

21.POP查看邮件的详细信息，也可以用跟踪TCP流的操作进行查看



<h2>E-Mail数据包的解密</h2>

1.通常用base64来实现加密

2.实验所需：python，FFV（文件类型识别），WinHex，Beyond Compare（）

3.实验数据包用上一次实验的数据包

4.用Wireshark来分析被加密的SMTP数据包并解密（方法1）

​           【1】用Wireshark打开STMP数据包，并用过滤器来筛选出STMP![43](D:\IT教程\网络协议\导图\43.PNG)



​           【2】选中第14号数据包，如果出现了双等号，就说明该文件被base64加密![44](D:\IT教程\网络协议\导图\44.PNG)

 

​             【3】在这里我们可以使用一些工具来帮助我们去解密（我用的是Base64V1.6）![45](D:\IT教程\网络协议\导图\45.PNG)



​            【4】将密码拷贝到软件里![46](D:\IT教程\网络协议\导图\46.PNG)![47](D:\IT教程\网络协议\导图\47.PNG)

​     

5.用Wireshark来分析被加密的SMTP数据包并解密（方法2）

​       【1】获取被加密的密码请参考方法1的第1步和第2步

​       【2】利用python来进行解密，这里会用到python在带的解密函数库,需要在cmd下完成，代码如下 （注：python再带base64函数）

```
C:\Users\86134>python
Python 3.9.10 (tags/v3.9.10:f2f3f53, Jan 17 2022, 15:14:21) [MSC v.1929 64 bit (AMD64)] on win32
Type "help", "copyright", "credits" or "license" for more information.
>>> import base64                            #导入base64模块
>>> base64. b64decode('cHVuamFiQDEyMw==')    #解密
b'punjab@123'
```





<h4>操作系统启动的数据包</h4>

1.实验里Wireshark的基本配置（如图所示）

​          【1】打开Wireshark，选择捕获，点击选项，选择虚拟网卡![48](D:\IT教程\网络协议\导图\48.PNG)![49](D:\IT教程\网络协议\导图\49.PNG)



2.用Wireshark来抓去Win Server2016启动时的数据包

​       【1】本次实验要用到虚拟机，我这里用的是VMware虚拟机软件，先启动Wireshark，在开启虚拟机![50](D:\IT教程\网络协议\导图\50.PNG)

​           【2】通过筛选器来筛选掉tcp与dns![51](D:\IT教程\网络协议\导图\51.PNG)

​         【3】在数据包里可以发现有许多的NBNS数据包，NBNS协议是网络的基本输入与输出系统的名称服务器。是 TCP/IP 上的 NetBIOS协议族的一部分。作用是提供主机名与地址映射的方法![52](D:\IT教程\网络协议\导图\52.PNG)



| 使用环境 |           局域网           |
| :------: | :------------------------: |
|   优点   | 占用系统资源小，传输效率高 |

​         

​          【4】在Windows系统里NBNS协议是默认开启的，通过抓包软件可以获取该主机名![53](D:\IT教程\网络协议\导图\53.PNG)



3.用Wireshark来抓去Ubuntu Linux 的启动数据包 （实验的第一步与上一个实验操作差不多）

​         【2】捕获结果 （ICMPv6是客户端请求获取IPV6的地址）![54](D:\IT教程\网络协议\导图\54.PNG)

​            

| 区别 |       Windows        |      Linux       |
| :--: | :------------------: | :--------------: |
|      | 默认情况下不支持IPV6 |   默认支持IPV6   |
|      |   默认开启NBNS协议   | 默认关闭NBNS协议 |

